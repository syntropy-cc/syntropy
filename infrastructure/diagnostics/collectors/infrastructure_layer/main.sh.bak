#!/bin/bash

# Resolve caminhos absolutos
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" &> /dev/null && pwd)"
CORE_DIR="$(cd "$SCRIPT_DIR/../../core" &> /dev/null && pwd)"
ENV_FILE="$(cd "$SCRIPT_DIR/../../../../" &> /dev/null && pwd)/.env"

# Importa dependências
source "$ENV_FILE" || exit 1
source "$CORE_DIR/logger.sh" || exit 1
source "$CORE_DIR/utils.sh" || exit 1
source "$CORE_DIR/json_handler.sh" || exit 1
source "$CORE_DIR/output_handler.sh" || exit 1

# Importa módulos de diagnóstico
source "$(dirname "$0")/docker_diagnostic.sh" || exit 1

# Carrega configuração da camada
readonly SCRIPT_DIR="$(dirname "$0")"
readonly CONFIG_FILE="$SCRIPT_DIR/config.json"
readonly LAYER_NAME="infrastructure"

# Inicializa logger
# Configura logger para usar o mesmo diretório base dos diagnósticos
LOG_BASE_DIR="${HOME}/.syntropy/diagnostics/logs"
mkdir -p "$LOG_BASE_DIR"
init_logger "$LAYER_NAME" "$(date +%Y%m%d_%H%M%S)" "$LOG_BASE_DIR"

validate_environment() {
    log_info "Validating environment for $LAYER_NAME layer"
    
    # Verifica versão do bash
    if [[ "${BASH_VERSION%%.*}" -lt 4 ]]; then
        log_error "Bash version 4.0 or higher is required"
        return 1
    fi
    
    # Verifica se docker está instalado
    if ! command -v docker >/dev/null 2>&1; then
        log_error "Docker is not installed"
        return 1
    fi
    
    # Verifica se jq está instalado
    if ! command -v jq >/dev/null 2>&1; then
        log_error "jq is not installed"
        return 1
    fi
    
    return 0
}

generate_outputs() {
    local start_time="$1"
    local current_time=$(date +%s%3N)
    local duration=$((current_time - start_time))
    
    # Inicializa output handler
    if ! init_output_handler "infrastructure"; then
        log_critical "Failed to initialize output handler"
        exit 1
    fi
    
    # Coleta resultados dos módulos
    local docker_status=$(run_docker_diagnostic)
    local container_status=$(run_container_diagnostic)
    local resource_status=$(run_resource_monitoring)
    local lifecycle_status=$(run_container_lifecycle)
    
    # Prepara conteúdo do summary
    local summary_content=""
    summary_content+="[INFRASTRUCTURE DIAGNOSTIC REPORT]\n"
    summary_content+="Timestamp: $(date -u +"%Y-%m-%dT%H:%M:%SZ")\n"
    summary_content+="Duration: ${duration}ms\n\n"
    summary_content+="-- DOCKER ENVIRONMENT --\n"
    summary_content+="$(echo "$docker_status" | jq -r '.docker_daemon | "• Docker Daemon: \(.status)"')\n"
    summary_content+="$(echo "$docker_status" | jq -r '.docker_compose | "• Docker Compose: \(.available)"')\n\n"
    summary_content+="-- CONTAINER STATUS --\n"
    summary_content+="$(echo "$container_status" | jq -r '"• Running: \(.running_count)/\(.total_count) containers"')\n"
    summary_content+="$(echo "$container_status" | jq -r '"• Health Checks: \(.status)"')\n\n"
    summary_content+="-- SYSTEM RESOURCES --\n"
    summary_content+="$(echo "$resource_status" | jq -r '.cpu | "• CPU Usage: \(.usage)% (\(.status)"')\n"
    summary_content+="$(echo "$resource_status" | jq -r '.memory | "• Memory Usage: \(.usage_percent)% (\(.status)"')\n"
    summary_content+="$(echo "$resource_status" | jq -r '.disk[0] | "• Disk Usage: \(.usage_percent)% (\(.status)"')\n\n"
    summary_content+="-- RECOMMENDATIONS --\n"
    summary_content+="$(generate_recommendations "$docker_status" "$container_status" "$resource_status")"

-- DOCKER ENVIRONMENT --
$(echo "$docker_status" | jq -r '.docker_daemon | "• Docker Daemon: \(.status)"')
$(echo "$docker_status" | jq -r '.docker_compose | "• Docker Compose: \(.available)"')

-- CONTAINER STATUS --
$(echo "$container_status" | jq -r '"• Running: \(.running_count)/\(.total_count) containers"')
$(echo "$container_status" | jq -r '"• Health Checks: \(.status)"')

-- SYSTEM RESOURCES --
$(echo "$resource_status" | jq -r '.cpu | "• CPU Usage: \(.usage)% (\(.status))"')
$(echo "$resource_status" | jq -r '.memory | "• Memory Usage: \(.usage_percent)% (\(.status))"')
$(echo "$resource_status" | jq -r '.disk[0] | "• Disk Usage: \(.usage_percent)% (\(.status))"')

-- RECOMMENDATIONS --
$(generate_recommendations "$docker_status" "$container_status" "$resource_status")
EOF

    # Gera results.json
    # Gera results.json usando output handler
    local results_json
    results_json=$(cat << 'EOF'
{
    "layer": "infrastructure",
    "timestamp": "${TIMESTAMP}",
    "duration_ms": ${duration},
    "status": "${OVERALL_STATUS}",
    "components": {
        "docker": ${docker_status},
        "containers": ${container_status},
        "resources": ${resource_status},
        "lifecycle": ${lifecycle_status}
    }
}
EOF
)
    
    # Substitui as variáveis
    results_json=$(echo "$results_json" | \
        TIMESTAMP="$(date -u +"%Y-%m-%dT%H:%M:%SZ")" \
        OVERALL_STATUS="$(get_overall_status "$docker_status" "$container_status" "$resource_status")" \
        envsubst)

    # Exporta outputs usando output handler
    generate_summary_txt "Infrastructure Layer Diagnostics" "$summary_content" || log_error "Failed to generate summary.txt"
    generate_results_json "$results_json" || log_error "Failed to generate results.json"
    copy_detailed_log "$(dirname "$0")/../../logs/infrastructure.log" || log_error "Failed to copy detailed.log"
    
    # Limpa outputs antigos
    cleanup_old_outputs 7
}

generate_recommendations() {
    local docker_status="$1"
    local container_status="$2"
    local resource_status="$3"
    
    # Analisa status e gera recomendações
    if [[ $(echo "$docker_status" | jq -r '.docker_daemon.status') != "HEALTHY" ]]; then
        echo "• CRITICAL: Docker daemon needs attention"
    fi
    
    if [[ $(echo "$container_status" | jq -r '.running_count') -lt 8 ]]; then
        echo "• WARNING: Some containers are not running"
    fi
    
    if [[ $(echo "$resource_status" | jq -r '.cpu.status') == "WARNING" ]]; then
        echo "• WARNING: High CPU usage detected"
    fi
    
    if [[ $(echo "$resource_status" | jq -r '.memory.status') == "WARNING" ]]; then
        echo "• WARNING: High memory usage detected"
    fi
}

get_overall_status() {
    local docker_status="$1"
    local container_status="$2"
    local resource_status="$3"
    
    # Determina status geral baseado nos componentes
    if [[ $(echo "$docker_status" | jq -r '.docker_daemon.status') == "CRITICAL" ]] || \
       [[ $(echo "$container_status" | jq -r '.status') == "CRITICAL" ]] || \
       [[ $(echo "$resource_status" | jq -r '.status') == "CRITICAL" ]]; then
        echo "CRITICAL"
    elif [[ $(echo "$docker_status" | jq -r '.docker_daemon.status') == "WARNING" ]] || \
         [[ $(echo "$container_status" | jq -r '.status') == "WARNING" ]] || \
         [[ $(echo "$resource_status" | jq -r '.status') == "WARNING" ]]; then
        echo "WARNING"
    else
        echo "HEALTHY"
    fi
}

main() {
    local start_time=$(date +%s%3N)
    
    log_info "Starting $LAYER_NAME layer diagnostics"
    
    # Valida ambiente
    if ! validate_environment; then
        log_error "Environment validation failed"
        exit 1
    fi
    
    # Executa módulos base
    if ! run_docker_diagnostic; then
        log_critical "Docker diagnostic failed"
        exit 1
    fi
    
    if ! run_container_diagnostic; then
        log_critical "Container diagnostic failed"
        exit 1
    fi
    
    # Executa módulos enhanced
    run_resource_monitoring
    run_container_lifecycle
    
    # Gera outputs
    generate_outputs "$start_time"
    
    # Inicia monitoramento se não estiver rodando
    if ! pgrep -f "monitor_infrastructure.sh" >/dev/null; then
        log_info "Starting infrastructure monitoring"
        "$(dirname "$0")/monitor.sh" start
    fi
}

# Executa main se chamado diretamente
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
