---
description: Rules for mocking, stubbing, and test doubles
globs: ["**/*.test.*", "**/*.spec.*", "**/test_*", "**/mocks/**"]
alwaysApply: false
priority: 3
---

# Mocking and Test Doubles Rules

## Purpose

Test doubles (mocks, stubs, fakes, spies) replace real dependencies during testing. Used correctly, they enable fast, isolated tests. Used incorrectly, they create brittle tests that pass even when the real system is broken. This file defines when and how to use each type of test double.

> **AI Instruction**: Before creating a mock, ask: "What am I trying to isolate?" If the answer is unclear, the mock is probably unnecessary. Prefer real implementations when practical; use mocks only at true system boundaries.

## Test Double Classification

### Rule MOCK-001: Understanding Test Double Types

Each type of test double serves a specific purpose:

```
┌─────────────────────────────────────────────────────────────────┐
│                      Test Double Types                           │
├──────────────┬──────────────────────────────────────────────────┤
│    Type      │    Purpose                                        │
├──────────────┼──────────────────────────────────────────────────┤
│    Dummy     │ Passed but never used. Satisfies parameter       │
│              │ requirements.                                     │
│              │ Example: def test(required_logger=None)          │
├──────────────┼──────────────────────────────────────────────────┤
│    Stub      │ Returns predetermined values. No logic.          │
│              │ Example: stub.get_user() returns fixed user      │
├──────────────┼──────────────────────────────────────────────────┤
│    Spy       │ Records calls for later verification.            │
│              │ Example: Verify email_service was called         │
├──────────────┼──────────────────────────────────────────────────┤
│    Mock      │ Pre-programmed expectations that verify          │
│              │ interactions occurred correctly.                  │
├──────────────┼──────────────────────────────────────────────────┤
│    Fake      │ Working implementation with shortcuts.           │
│              │ Example: In-memory database                       │
└──────────────┴──────────────────────────────────────────────────┘
```

### Rule MOCK-002: Choosing the Right Double

Selection guide based on testing need:

| Testing Need | Recommended Double | Example |
|--------------|-------------------|---------|
| Replace unused dependency | Dummy | `logger=None` |
| Control return values | Stub | Fixed API response |
| Verify method was called | Spy | Email was sent |
| Verify interaction details | Mock | Correct parameters passed |
| Need realistic behavior | Fake | In-memory repository |
| External service (testing) | Stub + Contract Test | Payment API |

```python
# Dummy: Satisfies signature, never used
def test_calculation_ignores_logger():
    result = calculate_total(items, logger=None)  # Dummy
    assert result == expected

# Stub: Returns predetermined values
def test_handles_api_response():
    api_stub = Mock()
    api_stub.get_user.return_value = User(id="123", name="Test")
    
    result = service.fetch_user("123", api=api_stub)
    assert result.name == "Test"

# Spy: Verifies calls happened
def test_sends_welcome_email():
    email_spy = Mock(spec=EmailService)
    
    user_service.create_user("test@example.com", email_service=email_spy)
    
    email_spy.send.assert_called_once()
    assert email_spy.send.call_args[0][0] == "test@example.com"

# Mock: Strict expectations
def test_payment_flow(mock_payment_gateway):
    mock_payment_gateway.charge.return_value = PaymentResult(success=True)
    
    order_service.complete_order(order)
    
    mock_payment_gateway.charge.assert_called_once_with(
        amount=order.total,
        customer_id=order.customer_id
    )

# Fake: Lightweight real implementation
class FakeUserRepository:
    def __init__(self):
        self._users = {}
    
    def save(self, user):
        self._users[user.id] = user
    
    def find_by_id(self, user_id):
        return self._users.get(user_id)
```

## Mocking Best Practices

### Rule MOCK-003: Mock at System Boundaries

Only mock at the edges of your system. The diagram below illustrates the boundaries where mocking is appropriate, and the areas within where you should use real implementations:

```
External World                    Your System
     │                                 │
     │    ┌────────────────────────────┴────────────────────────────┐
     │    │                                                          │
     │    │   ┌──────────┐    ┌──────────┐    ┌──────────┐         │
     ▼    │   │ Service  │───▶│  Domain  │───▶│Use Case  │         │
   ──────►│   │  Layer   │    │  Layer   │    │  Layer   │         │
   Mock   │   └──────────┘    └──────────┘    └──────────┘         │
   Here   │        │                                │               │
          │        │         DO NOT MOCK            │               │
          │        │         THIS AREA              │               │
          │        ▼                                ▼               │
          │   ┌──────────┐                   ┌──────────┐          │
          │   │Repository│                   │  Ports   │          │
          │   │Interface │                   │(Abstract)│          │
          │   └────┬─────┘                   └────┬─────┘          │
          │        │                              │                │
          └────────┼──────────────────────────────┼────────────────┘
                   │                              │
                   ▼ Mock Here                    ▼ Mock Here
            ┌──────────┐                   ┌──────────┐
            │ Database │                   │ External │
            │          │                   │   API    │
            └──────────┘                   └──────────┘
```

The key insight here is that mocking internal collaborators (like services calling other services) leads to tests that are tightly coupled to implementation details. When you refactor how components interact, those tests break even if behavior is preserved.

```python
# CORRECT: Mock at boundary (repository interface)
def test_user_service_creates_user():
    repo_mock = Mock(spec=UserRepository)
    service = UserService(repository=repo_mock)
    
    service.create_user("test@example.com")
    
    repo_mock.save.assert_called_once()

# INCORRECT: Mocking internal collaborator
def test_order_service():
    # Don't mock domain objects or internal services
    order_mock = Mock(spec=Order)  # Bad: mocking domain object
    calculator_mock = Mock(spec=PriceCalculator)  # Bad: internal collaborator
```

### Rule MOCK-004: Prefer Fakes Over Mocks for Complex Dependencies

When a dependency has complex behavior, fakes provide more realistic testing than mocks while still maintaining test isolation:

```python
# Fake repository for testing
class FakeUserRepository:
    """
    In-memory implementation for testing.
    Mirrors real repository behavior without database.
    """
    def __init__(self):
        self._users: dict[str, User] = {}
        self._email_index: dict[str, str] = {}
    
    def save(self, user: User) -> None:
        if user.id is None:
            user.id = str(uuid.uuid4())
        
        # Enforce unique email constraint like real DB would
        existing_id = self._email_index.get(user.email)
        if existing_id and existing_id != user.id:
            raise DuplicateEmailError(user.email)
        
        self._users[user.id] = user
        self._email_index[user.email] = user.id
    
    def find_by_id(self, user_id: str) -> User | None:
        return self._users.get(user_id)
    
    def find_by_email(self, email: str) -> User | None:
        user_id = self._email_index.get(email)
        return self._users.get(user_id) if user_id else None
    
    def delete(self, user_id: str) -> None:
        user = self._users.pop(user_id, None)
        if user:
            del self._email_index[user.email]


# Using fake in tests
def test_cannot_create_duplicate_email(fake_user_repository):
    service = UserService(repository=fake_user_repository)
    
    service.create_user("test@example.com")
    
    with pytest.raises(DuplicateEmailError):
        service.create_user("test@example.com")


# Fake for external API
class FakePaymentGateway:
    """Fake payment gateway for testing."""
    
    def __init__(self):
        self.charges: list[dict] = []
        self._should_decline = False
        self._should_timeout = False
    
    def charge(self, amount: Decimal, card_token: str) -> PaymentResult:
        if self._should_timeout:
            raise TimeoutError("Connection timed out")
        
        if self._should_decline:
            return PaymentResult(success=False, error="Card declined")
        
        charge_id = f"ch_{uuid.uuid4().hex[:16]}"
        self.charges.append({
            "id": charge_id,
            "amount": amount,
            "card_token": card_token
        })
        return PaymentResult(success=True, charge_id=charge_id)
    
    # Test helpers
    def simulate_decline(self):
        self._should_decline = True
    
    def simulate_timeout(self):
        self._should_timeout = True
```

### Rule MOCK-005: Use spec= for Type Safety

Always use `spec=` to ensure mocks match the interface they're replacing:

```python
# BAD: Untyped mock accepts any attribute
def test_user_creation():
    repo = Mock()
    service = UserService(repository=repo)
    
    service.create_user("test@example.com")
    
    # Typo goes unnoticed! Test passes but code is wrong
    repo.svae.assert_called_once()  # Should be 'save'

# GOOD: spec catches typos and invalid attributes
def test_user_creation():
    repo = Mock(spec=UserRepository)
    service = UserService(repository=repo)
    
    service.create_user("test@example.com")
    
    repo.svae.assert_called_once()  # AttributeError: Mock has no attribute 'svae'


# BETTER: autospec for full signature checking
def test_user_creation():
    repo = create_autospec(UserRepository)
    service = UserService(repository=repo)
    
    service.create_user("test@example.com")
    
    # Also catches wrong number of arguments
    repo.save.assert_called_once()
```

### Rule MOCK-006: Avoid Over-Specification

Test behavior, not implementation. Over-specified mocks make tests brittle:

```python
# BAD: Over-specified mock verification
def test_order_completion():
    payment = Mock(spec=PaymentService)
    payment.charge.return_value = PaymentResult(success=True, id="ch_123")
    
    inventory = Mock(spec=InventoryService)
    notification = Mock(spec=NotificationService)
    
    service = OrderService(payment, inventory, notification)
    service.complete_order(order)
    
    # Over-specification: These tests break with any refactoring
    payment.charge.assert_called_once_with(
        amount=Decimal("99.99"),
        currency="USD",
        customer_id="cust_123",
        idempotency_key="order_456",  # Implementation detail
        metadata={"order_id": "456"}  # Implementation detail
    )
    inventory.reserve.assert_called_before(payment.charge)  # Order dependency
    notification.send.assert_called_with(
        template="order_confirmation",  # Implementation detail
        recipient="test@example.com",
        context={"order_id": "456", "total": "99.99"}  # Too specific
    )

# GOOD: Verify essential behavior only
def test_order_completion_charges_payment():
    payment = Mock(spec=PaymentService)
    payment.charge.return_value = PaymentResult(success=True)
    
    service = OrderService(payment, Mock(), Mock())
    service.complete_order(order)
    
    # Verify the essential interaction
    payment.charge.assert_called_once()
    call_kwargs = payment.charge.call_args.kwargs
    assert call_kwargs["amount"] == order.total
    assert call_kwargs["customer_id"] == order.customer_id

def test_order_completion_sends_confirmation():
    notification = Mock(spec=NotificationService)
    
    service = OrderService(Mock(), Mock(), notification)
    service.complete_order(order)
    
    notification.send.assert_called_once()
    assert notification.send.call_args.kwargs["recipient"] == order.customer_email
```

## Mocking Patterns

### Rule MOCK-007: Time Mocking

Always mock time-dependent behavior to ensure deterministic tests:

```python
# Using freezegun
from freezegun import freeze_time

@freeze_time("2024-01-15 10:30:00")
def test_subscription_expiry_check():
    subscription = Subscription(
        starts_at=datetime(2024, 1, 1),
        duration_days=30
    )
    
    assert subscription.is_active()  # True at Jan 15
    
@freeze_time("2024-02-15 10:30:00")
def test_subscription_has_expired():
    subscription = Subscription(
        starts_at=datetime(2024, 1, 1),
        duration_days=30
    )
    
    assert not subscription.is_active()  # False at Feb 15


# For more control, use time_machine or manual injection
def test_trial_period_calculation(frozen_time):
    frozen_time.move_to("2024-01-01")
    user = User.create_with_trial()
    
    frozen_time.move_to("2024-01-07")
    assert user.trial_days_remaining == 7
    
    frozen_time.move_to("2024-01-14")
    assert user.trial_days_remaining == 0


# Dependency injection approach (more explicit)
def test_subscription_renewal():
    clock = FakeClock(datetime(2024, 1, 15))
    subscription = Subscription(clock=clock)
    
    subscription.renew()
    
    assert subscription.expires_at == datetime(2024, 2, 14)
```

### Rule MOCK-008: Network Mocking

Mock HTTP calls at the request level:

```python
# Using responses library for requests
import responses

@responses.activate
def test_fetches_user_from_api():
    responses.add(
        responses.GET,
        "https://api.example.com/users/123",
        json={"id": "123", "name": "Test User"},
        status=200
    )
    
    client = APIClient(base_url="https://api.example.com")
    user = client.get_user("123")
    
    assert user.name == "Test User"

@responses.activate
def test_handles_api_timeout():
    responses.add(
        responses.GET,
        "https://api.example.com/users/123",
        body=requests.Timeout("Connection timed out")
    )
    
    client = APIClient(base_url="https://api.example.com")
    
    with pytest.raises(ServiceUnavailableError):
        client.get_user("123")


# Using httpx with respx
import respx

@respx.mock
async def test_async_api_call():
    respx.get("https://api.example.com/users/123").mock(
        return_value=httpx.Response(200, json={"id": "123"})
    )
    
    async with httpx.AsyncClient() as client:
        response = await client.get("https://api.example.com/users/123")
    
    assert response.json()["id"] == "123"
```

### Rule MOCK-009: File System Mocking

Isolate tests from the real file system:

```python
# Using pyfakefs
def test_file_processing(fs):
    """Test with fake file system (pyfakefs injects 'fs' fixture)."""
    # Create fake files
    fs.create_file("/data/input.csv", contents="name,value\ntest,123")
    
    # Test file processing
    result = process_csv("/data/input.csv")
    
    assert result[0]["name"] == "test"
    
    # Verify output
    assert fs.exists("/data/output.json")


# Using temp directories
def test_file_export(tmp_path):
    """Test with real temp directory."""
    output_file = tmp_path / "export.csv"
    
    export_data(data, output_file)
    
    assert output_file.exists()
    content = output_file.read_text()
    assert "expected_data" in content


# Manual mocking for specific cases
def test_handles_permission_error(monkeypatch):
    def mock_open(*args, **kwargs):
        raise PermissionError("Access denied")
    
    monkeypatch.setattr("builtins.open", mock_open)
    
    with pytest.raises(FileAccessError):
        file_service.read_config("/etc/config")
```

### Rule MOCK-010: Database Mocking Strategy

For database operations, prefer transaction rollback over mocking:

```python
# PREFERRED: Use real database with transaction rollback
@pytest.fixture
def db_session(engine):
    """Real database, rolled back after each test."""
    connection = engine.connect()
    transaction = connection.begin()
    session = Session(bind=connection)
    
    yield session
    
    session.close()
    transaction.rollback()
    connection.close()

def test_user_persistence(db_session, user_factory):
    user = user_factory.create(session=db_session)
    
    found = db_session.query(User).filter_by(id=user.id).first()
    
    assert found is not None
    assert found.email == user.email


# ACCEPTABLE: Fake repository for unit tests
def test_user_service_with_fake():
    fake_repo = FakeUserRepository()
    service = UserService(repository=fake_repo)
    
    service.create_user("test@example.com")
    
    assert fake_repo.find_by_email("test@example.com") is not None


# AVOID: Mocking repository methods (too coupled)
def test_user_service_with_mock():
    mock_repo = Mock(spec=UserRepository)
    service = UserService(repository=mock_repo)
    
    service.create_user("test@example.com")
    
    mock_repo.save.assert_called_once()  # Tests implementation, not behavior
```

## Context Managers and Patches

### Rule MOCK-011: Patch Scope

Apply patches at the narrowest scope possible:

```python
# GOOD: Patch only what's needed, where it's used
def test_sends_email_on_registration():
    with patch("myapp.services.user_service.send_email") as mock_send:
        user_service.register("test@example.com")
        
        mock_send.assert_called_once()

# GOOD: Decorator for entire test
@patch("myapp.services.user_service.send_email")
def test_sends_welcome_email(mock_send):
    user_service.register("test@example.com")
    mock_send.assert_called_once()

# GOOD: Class-level for related tests
@patch("myapp.services.user_service.send_email")
class TestUserRegistration:
    def test_sends_welcome_email(self, mock_send):
        user_service.register("test@example.com")
        mock_send.assert_called_once()
    
    def test_email_contains_activation_link(self, mock_send):
        user_service.register("test@example.com")
        call_kwargs = mock_send.call_args.kwargs
        assert "activate" in call_kwargs["body"]


# BAD: Module-level patch (affects all tests)
@patch("myapp.services.user_service.send_email")  # Too broad!
class TestEverything:
    def test_unrelated_thing(self, mock_send):
        # This test doesn't need email mocked but gets it anyway
        ...
```

### Rule MOCK-012: Patch Target Location

Patch where the name is looked up, not where it's defined:

```python
# myapp/services/user_service.py
from myapp.email import send_email  # Imported here

class UserService:
    def register(self, email):
        # ... registration logic ...
        send_email(to=email, subject="Welcome")


# CORRECT: Patch where it's used (looked up)
@patch("myapp.services.user_service.send_email")
def test_registration(mock_send):
    service = UserService()
    service.register("test@example.com")
    mock_send.assert_called_once()


# INCORRECT: Patching where it's defined won't work
@patch("myapp.email.send_email")  # Won't affect user_service!
def test_registration(mock_send):
    service = UserService()
    service.register("test@example.com")
    mock_send.assert_called_once()  # Fails - real function was called
```

## Async Mocking

### Rule MOCK-013: Async Mock Patterns

Handle async code properly in tests:

```python
import pytest
from unittest.mock import AsyncMock, patch

# AsyncMock for async methods
@pytest.mark.asyncio
async def test_async_user_fetch():
    mock_client = AsyncMock(spec=APIClient)
    mock_client.get_user.return_value = User(id="123", name="Test")
    
    service = UserService(client=mock_client)
    user = await service.fetch_user("123")
    
    assert user.name == "Test"
    mock_client.get_user.assert_awaited_once_with("123")


# Patching async functions
@pytest.mark.asyncio
@patch("myapp.services.fetch_remote_data", new_callable=AsyncMock)
async def test_with_patched_async(mock_fetch):
    mock_fetch.return_value = {"status": "ok"}
    
    result = await process_remote_data()
    
    assert result.status == "ok"


# Async context managers
@pytest.mark.asyncio
async def test_async_context_manager():
    mock_session = AsyncMock()
    mock_session.__aenter__.return_value = mock_session
    mock_session.__aexit__.return_value = None
    mock_session.execute.return_value = [{"id": 1}]
    
    async with mock_session as session:
        result = await session.execute("SELECT * FROM users")
    
    assert len(result) == 1
```

## Anti-Patterns to Avoid

### Rule MOCK-014: Mocking Anti-Patterns

These patterns indicate problematic test design:

```python
# ANTI-PATTERN 1: Mocking the subject under test
def test_user_validation():
    user = Mock(spec=User)
    user.is_valid.return_value = True  # Mocking what we're testing!
    
    assert user.is_valid()  # Meaningless - we're testing the mock

# ANTI-PATTERN 2: Mocking everything
def test_over_mocked():
    mock_user = Mock()
    mock_order = Mock()
    mock_product = Mock()
    mock_calculator = Mock()
    
    # At this point we're just testing that mocks return what we told them
    result = process(mock_user, mock_order, mock_product, mock_calculator)

# ANTI-PATTERN 3: Mock returning mocks
def test_mock_chain():
    mock_db = Mock()
    mock_db.session.query.return_value.filter.return_value.first.return_value = user
    # Fragile: breaks if query structure changes

# ANTI-PATTERN 4: Testing mock interactions instead of outcomes
def test_calls_methods_in_order():
    mock = Mock()
    
    some_function(mock)
    
    # Testing implementation details, not behavior
    assert mock.method_calls == [
        call.setup(),
        call.process(),
        call.cleanup()
    ]
```

The fundamental principle is that mocking should enable testing, not become the focus of testing. If you find yourself spending more time configuring mocks than writing meaningful assertions, reconsider your approach.
