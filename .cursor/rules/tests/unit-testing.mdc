---
description: Rules specific to unit testing
globs: ["**/unit/**", "**/test_*.py", "**/*.unit.test.*"]
alwaysApply: false
priority: 2
---

# Unit Testing Rules

## Purpose

Unit tests verify the smallest testable parts of the application in isolation. They are the foundation of the test pyramid and should constitute the majority of your tests. This file defines standards for writing effective unit tests.

> **AI Instruction**: Unit tests must be fast, isolated, and focused. If you find yourself needing a database, network, or file system, you're not writing a unit test. Either mock the dependency or reclassify the test.

## Scope Definition

### Rule UNIT-001: What Constitutes a Unit

A "unit" is the smallest piece of code that can be logically tested in isolation. This is typically:

| Language | Unit | Example |
|----------|------|---------|
| Python | Function, method, or class | `calculate_tax()`, `User.validate()` |
| JavaScript/TypeScript | Function, method, or module | `formatDate()`, `UserService.create()` |
| Go | Function or method | `CalculateTax()`, `(*User).Validate()` |

**A unit test**:
- Tests one unit in isolation
- Mocks all external dependencies
- Runs entirely in memory
- Completes in milliseconds

### Rule UNIT-002: Unit Test Boundaries

Unit tests should NOT cross these boundaries:

```
┌─────────────────────────────────────────────────────┐
│                  Unit Test Scope                     │
│                                                      │
│   ┌──────────────────────────────────────────────┐  │
│   │           Code Under Test                     │  │
│   │   • Business logic                           │  │
│   │   • Calculations                             │  │
│   │   • Transformations                          │  │
│   │   • Validations                              │  │
│   │   • State machines                           │  │
│   └──────────────────────────────────────────────┘  │
│                         │                            │
│    ─────────────────────┼────────────────────────   │
│                         │ MOCK BOUNDARY              │
│                         ▼                            │
│   ┌──────────────────────────────────────────────┐  │
│   │           Mocked Dependencies                 │  │
│   │   • Repositories                             │  │
│   │   • External services                        │  │
│   │   • File system                              │  │
│   │   • Network calls                            │  │
│   │   • System clock                             │  │
│   └──────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────┘
```

## Domain Logic Testing

### Rule UNIT-003: Entity Testing

Test entities for business rule enforcement:

```python
class TestOrder:
    """Tests for the Order entity business rules."""
    
    def test_order_cannot_be_modified_after_shipping(self):
        order = Order(status=OrderStatus.SHIPPED)
        
        with pytest.raises(OrderModificationError) as exc_info:
            order.add_item(Product(id="123"))
        
        assert "shipped" in str(exc_info.value).lower()
    
    def test_order_total_sums_all_line_items(self):
        order = Order()
        order.add_item(Product(price=Decimal("10.00")), quantity=2)
        order.add_item(Product(price=Decimal("5.00")), quantity=3)
        
        # 2 * $10 + 3 * $5 = $35
        assert order.total == Decimal("35.00")
    
    def test_order_applies_discount_code(self):
        order = Order()
        order.add_item(Product(price=Decimal("100.00")), quantity=1)
        
        order.apply_discount(DiscountCode(percentage=20))
        
        assert order.total == Decimal("80.00")
        assert order.discount_amount == Decimal("20.00")
```

### Rule UNIT-004: Value Object Testing

Test value objects for immutability and equality:

```python
class TestMoney:
    """Tests for Money value object."""
    
    def test_money_equality_by_value(self):
        money1 = Money(amount=Decimal("100.00"), currency="USD")
        money2 = Money(amount=Decimal("100.00"), currency="USD")
        
        assert money1 == money2
        assert money1 is not money2  # Different instances
    
    def test_money_addition_returns_new_instance(self):
        original = Money(amount=Decimal("50.00"), currency="USD")
        
        result = original.add(Money(amount=Decimal("25.00"), currency="USD"))
        
        assert result.amount == Decimal("75.00")
        assert original.amount == Decimal("50.00")  # Unchanged
    
    def test_money_cannot_add_different_currencies(self):
        usd = Money(amount=Decimal("100.00"), currency="USD")
        eur = Money(amount=Decimal("100.00"), currency="EUR")
        
        with pytest.raises(CurrencyMismatchError):
            usd.add(eur)
```

### Rule UNIT-005: Domain Service Testing

Test domain services with mocked dependencies:

```python
class TestPricingService:
    """Tests for PricingService domain service."""
    
    def test_premium_customers_get_discounted_price(self):
        # Arrange
        pricing_rules = Mock(spec=PricingRules)
        pricing_rules.get_discount_for_tier.return_value = Decimal("0.15")
        
        service = PricingService(pricing_rules)
        customer = Customer(tier=CustomerTier.PREMIUM)
        product = Product(base_price=Decimal("100.00"))
        
        # Act
        price = service.calculate_price(product, customer)
        
        # Assert
        assert price == Decimal("85.00")  # 15% discount
        pricing_rules.get_discount_for_tier.assert_called_once_with(CustomerTier.PREMIUM)
    
    def test_price_cannot_go_below_minimum_margin(self):
        pricing_rules = Mock(spec=PricingRules)
        pricing_rules.get_discount_for_tier.return_value = Decimal("0.50")  # 50% discount
        pricing_rules.minimum_margin = Decimal("0.10")  # 10% minimum
        
        service = PricingService(pricing_rules)
        product = Product(base_price=Decimal("100.00"), cost=Decimal("80.00"))
        
        price = service.calculate_price(product, Customer(tier=CustomerTier.VIP))
        
        # Cannot go below cost + minimum margin = $80 + $8 = $88
        assert price >= Decimal("88.00")
```

## Application Service Testing

### Rule UNIT-006: Use Case Testing

Test application services (use cases) by mocking all infrastructure:

```python
class TestCreateOrderUseCase:
    """Tests for CreateOrder use case."""
    
    @pytest.fixture
    def use_case(self, mock_order_repo, mock_inventory, mock_event_bus):
        return CreateOrderUseCase(
            order_repository=mock_order_repo,
            inventory_service=mock_inventory,
            event_bus=mock_event_bus
        )
    
    def test_creates_order_with_valid_items(self, use_case, mock_order_repo, mock_inventory):
        # Arrange
        mock_inventory.check_availability.return_value = True
        command = CreateOrderCommand(
            customer_id="cust-123",
            items=[OrderItemDTO(product_id="prod-456", quantity=2)]
        )
        
        # Act
        result = use_case.execute(command)
        
        # Assert
        assert result.is_success
        mock_order_repo.save.assert_called_once()
        saved_order = mock_order_repo.save.call_args[0][0]
        assert saved_order.customer_id == "cust-123"
        assert len(saved_order.items) == 1
    
    def test_fails_when_item_out_of_stock(self, use_case, mock_inventory, mock_order_repo):
        mock_inventory.check_availability.return_value = False
        command = CreateOrderCommand(
            customer_id="cust-123",
            items=[OrderItemDTO(product_id="prod-456", quantity=100)]
        )
        
        result = use_case.execute(command)
        
        assert result.is_failure
        assert result.error.code == "OUT_OF_STOCK"
        mock_order_repo.save.assert_not_called()
    
    def test_publishes_order_created_event_on_success(self, use_case, mock_event_bus, mock_inventory):
        mock_inventory.check_availability.return_value = True
        command = CreateOrderCommand(
            customer_id="cust-123",
            items=[OrderItemDTO(product_id="prod-456", quantity=1)]
        )
        
        use_case.execute(command)
        
        mock_event_bus.publish.assert_called_once()
        event = mock_event_bus.publish.call_args[0][0]
        assert isinstance(event, OrderCreatedEvent)
```

## Pure Function Testing

### Rule UNIT-007: Testing Pure Functions

Pure functions (no side effects, same input = same output) are the easiest to test:

```python
class TestTaxCalculation:
    """Tests for tax calculation pure functions."""
    
    @pytest.mark.parametrize("subtotal,tax_rate,expected", [
        (Decimal("100.00"), Decimal("0.10"), Decimal("10.00")),
        (Decimal("50.00"), Decimal("0.08"), Decimal("4.00")),
        (Decimal("0.00"), Decimal("0.10"), Decimal("0.00")),
        (Decimal("99.99"), Decimal("0.0725"), Decimal("7.25")),  # Rounded
    ])
    def test_calculates_tax_correctly(self, subtotal, tax_rate, expected):
        result = calculate_tax(subtotal, tax_rate)
        assert result == expected
    
    @pytest.mark.parametrize("invalid_rate", [
        Decimal("-0.10"),  # Negative
        Decimal("1.50"),   # Over 100%
    ])
    def test_rejects_invalid_tax_rates(self, invalid_rate):
        with pytest.raises(InvalidTaxRateError):
            calculate_tax(Decimal("100.00"), invalid_rate)
```

## Edge Cases and Boundaries

### Rule UNIT-008: Boundary Testing

Always test boundary conditions:

```python
class TestPasswordValidation:
    """Tests for password validation boundary conditions."""
    
    # Minimum length boundary (assuming min is 8)
    def test_accepts_password_at_minimum_length(self):
        result = validate_password("Abcd123!")  # Exactly 8 chars
        assert result.is_valid
    
    def test_rejects_password_one_below_minimum(self):
        result = validate_password("Abcd12!")  # 7 chars
        assert not result.is_valid
        assert "minimum" in result.error.lower()
    
    # Maximum length boundary (assuming max is 128)
    def test_accepts_password_at_maximum_length(self):
        password = "A" * 126 + "1!"  # Exactly 128 chars
        result = validate_password(password)
        assert result.is_valid
    
    def test_rejects_password_one_above_maximum(self):
        password = "A" * 127 + "1!"  # 129 chars
        result = validate_password(password)
        assert not result.is_valid


class TestPagination:
    """Tests for pagination boundary conditions."""
    
    def test_first_page(self):
        result = paginate(items=list(range(100)), page=1, per_page=10)
        assert result.items == list(range(10))
        assert result.has_previous is False
        assert result.has_next is True
    
    def test_last_page(self):
        result = paginate(items=list(range(100)), page=10, per_page=10)
        assert result.items == list(range(90, 100))
        assert result.has_previous is True
        assert result.has_next is False
    
    def test_page_beyond_total(self):
        result = paginate(items=list(range(100)), page=11, per_page=10)
        assert result.items == []
        assert result.has_next is False
    
    def test_partial_last_page(self):
        result = paginate(items=list(range(95)), page=10, per_page=10)
        assert result.items == list(range(90, 95))  # Only 5 items
        assert result.has_next is False
```

### Rule UNIT-009: Null and Empty Testing

Always test null, empty, and missing value scenarios:

```python
class TestUserNameFormatting:
    """Tests for edge cases in name formatting."""
    
    def test_formats_full_name(self):
        assert format_name("John", "Doe") == "John Doe"
    
    def test_handles_missing_last_name(self):
        assert format_name("Madonna", None) == "Madonna"
    
    def test_handles_missing_first_name(self):
        assert format_name(None, "Prince") == "Prince"
    
    def test_handles_both_names_missing(self):
        assert format_name(None, None) == ""
    
    def test_handles_empty_strings(self):
        assert format_name("", "Doe") == "Doe"
        assert format_name("John", "") == "John"
    
    def test_trims_whitespace(self):
        assert format_name("  John  ", "  Doe  ") == "John Doe"
```

## State Machine Testing

### Rule UNIT-010: State Transition Testing

For objects with state machines, test all valid transitions and verify invalid ones are rejected:

```python
class TestOrderStateMachine:
    """Tests for Order state transitions."""
    
    # Valid transitions
    @pytest.mark.parametrize("initial,action,expected", [
        (OrderStatus.DRAFT, "submit", OrderStatus.PENDING),
        (OrderStatus.PENDING, "approve", OrderStatus.APPROVED),
        (OrderStatus.APPROVED, "ship", OrderStatus.SHIPPED),
        (OrderStatus.SHIPPED, "deliver", OrderStatus.DELIVERED),
        (OrderStatus.PENDING, "cancel", OrderStatus.CANCELLED),
    ])
    def test_valid_state_transitions(self, initial, action, expected):
        order = Order(status=initial)
        
        getattr(order, action)()
        
        assert order.status == expected
    
    # Invalid transitions
    @pytest.mark.parametrize("initial,action", [
        (OrderStatus.DRAFT, "ship"),       # Can't ship draft
        (OrderStatus.SHIPPED, "cancel"),   # Can't cancel shipped
        (OrderStatus.DELIVERED, "approve"), # Can't approve delivered
        (OrderStatus.CANCELLED, "submit"),  # Can't resubmit cancelled
    ])
    def test_invalid_state_transitions_raise_error(self, initial, action):
        order = Order(status=initial)
        
        with pytest.raises(InvalidStateTransitionError) as exc_info:
            getattr(order, action)()
        
        assert exc_info.value.current_state == initial
        assert exc_info.value.attempted_action == action
```

## Test Organization

### Rule UNIT-011: File Organization

Organize unit tests to mirror source structure:

```
src/
├── domain/
│   ├── user/
│   │   ├── entity.py
│   │   └── value_objects.py
│   └── order/
│       ├── entity.py
│       └── service.py
└── application/
    └── use_cases/
        └── create_order.py

tests/
└── unit/
    ├── domain/
    │   ├── user/
    │   │   ├── test_entity.py        # Tests for user/entity.py
    │   │   └── test_value_objects.py
    │   └── order/
    │       ├── test_entity.py
    │       └── test_service.py
    └── application/
        └── use_cases/
            └── test_create_order.py
```

### Rule UNIT-012: Test Class Organization

Group related tests in classes:

```python
class TestUserRegistration:
    """Unit tests for user registration logic."""
    
    class TestEmailValidation:
        """Tests specifically for email validation during registration."""
        
        def test_accepts_valid_email(self): ...
        def test_rejects_email_without_at_symbol(self): ...
        def test_rejects_email_without_domain(self): ...
    
    class TestPasswordRequirements:
        """Tests for password requirements during registration."""
        
        def test_requires_minimum_length(self): ...
        def test_requires_uppercase_letter(self): ...
        def test_requires_special_character(self): ...
    
    class TestDuplicateDetection:
        """Tests for duplicate email detection."""
        
        def test_rejects_existing_email(self): ...
        def test_email_comparison_is_case_insensitive(self): ...
```

## Performance

### Rule UNIT-013: Unit Test Speed

Unit tests must be fast. If a unit test takes more than 100ms, investigate:

```python
import pytest

# Mark slow tests for identification
@pytest.mark.slow
def test_complex_calculation():
    """This test is known to be slow due to algorithm complexity."""
    ...

# Use pytest-timeout to enforce limits
@pytest.mark.timeout(0.1)  # 100ms limit
def test_must_be_fast():
    ...
```

**Common causes of slow unit tests**:
- Unnecessary I/O (database, files, network)
- Expensive setup that should be shared
- Actually testing too much (should be integration test)
- Inefficient test data creation

## Fixtures

### Rule UNIT-014: Fixture Guidelines

Use fixtures for reusable test setup:

```python
# conftest.py
@pytest.fixture
def user_factory():
    """Factory for creating test users."""
    return UserFactory()

@pytest.fixture
def mock_repository():
    """Pre-configured mock repository."""
    repo = Mock(spec=UserRepository)
    repo.find_by_id.return_value = None  # Default behavior
    return repo

@pytest.fixture
def valid_registration_data():
    """Standard valid registration payload."""
    return {
        "email": "test@example.com",
        "password": "SecurePass123!",
        "name": "Test User"
    }

# In test file
def test_registration_succeeds(user_factory, mock_repository, valid_registration_data):
    # Fixtures are injected and ready to use
    ...
```

**Fixture scope guidance**:
- `function` (default): New instance per test
- `class`: Shared within test class
- `module`: Shared within module (use sparingly)
- `session`: Shared across all tests (almost never for unit tests)
